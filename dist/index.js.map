{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import {\n  h,\n  cloneElement,\n  render,\n  hydrate,\n  type FunctionComponent,\n  type ComponentClass,\n  type FunctionalComponent,\n  type VNode,\n} from 'preact';\n\ntype PreactComponent =\n  FunctionComponent<any> |\n  ComponentClass<any> |\n  FunctionalComponent<any>;\n\nexport type AttributeValue = null | string | boolean | number;\nexport type AttributeParser<T> = (a: AttributeValue) => T;\nexport type AttributeUnparser<T> = (p: T) => AttributeValue;\n\nexport type AttributeConfig<T> =\n  AttributeParser<T> |\n  { parse: AttributeParser<T>, reflect: AttributeUnparser<T> };\n\ntype Options = {\n  adoptedStyleSheets?: CSSStyleSheet[],\n  slots?: string[],\n  properties?: string[],\n  formAssociated?: string,\n  attributes?: Record<string, AttributeConfig<any>>,\n};\n\nconst toCamelCase = (str: string) => (\n  str.replace(/-(\\w)/g, (_, c) => (c ? c.toUpperCase() : ''))\n);\n\nconst Slot = (props: { name?: string }) => (\n  h(\"slot\", props)\n);\n\nexport const makeCustomElement = (Component: PreactComponent, options: Options) => {\n  class PreactElement extends HTMLElement {\n    static observedAttributes = Object.keys(options.attributes ?? {});\n    static formAssociated = !!options.formAssociated;\n    _root;\n    _vdom;\n    _initialProps;\n    _internals;\n\n    constructor () {\n      super();\n      // This library assumes that the ShadowDOM feature is always enabled\n      this._root = this.attachShadow({ mode: \"open\" });\n      this._vdom = null as (VNode | null);\n      this._internals = options.formAssociated ? this.attachInternals() : null;\n      this._initialProps = {} as Record<string, any>;\n      if (options.adoptedStyleSheets) {\n        this._root.adoptedStyleSheets = options.adoptedStyleSheets;\n      }\n    }\n\n    // Reflect prop/attr change to Preact props\n    // -- Maybe VALUE cannot be typed in TypeScript.\n    updateProp (name: string, value: any) {\n      // Before the first render: reserve the new value for the first render\n      if (!this._vdom) {\n        this._initialProps[name] = value;\n        this._initialProps[toCamelCase(name)] = value;\n        return;\n      }\n      // After the first render: rerender UI with the new value\n      const props = { [name]: value, [toCamelCase(name)]: value };\n      this._vdom = cloneElement(this._vdom, props);\n      render(this._vdom, this._root);\n    }\n\n    // Reflect raw attr value to Preact props if appropreate\n    parseAttribute (\n      name: string,\n      rawValue: any,\n      prepend?: boolean /* = do not overwrite existing values */\n    ) {\n      if (prepend && this._initialProps?.hasOwnProperty(name)) {\n        return;\n      }\n      if (options.attributes?.[name]) {\n        const config = options.attributes[name];\n        const parser = (\"parse\" in config) ? config.parse : config;\n        if (parser) {\n          // Attributes value defaults to null, but Preact props value defaults to undef.\n          // So we convert here for usability.\n          this.updateProp(name, parser(rawValue ?? undefined));\n        }\n      }\n    }\n\n    connectedCallback () {\n      const { attributes, childNodes } = this;\n      // Parse attributes.\n      // Results are accumulated in `this._initialProps` by `updateProp`.\n      for (let i = 0; i < attributes.length; i++) {\n        this.parseAttribute(attributes[i].name, attributes[i].value, true);\n      }\n      const props = this._initialProps ?? {};\n      (options.slots ?? []).forEach(name => {\n        props[name] = h(Slot, { name }, null)\n      });\n      this._vdom = h(Component, props, h(Slot, { name: undefined }, null));\n      // TODO: I don't know how this works (just copy-pasted from preact-custom-component)\n      (this.hasAttribute('hydrate') ? hydrate : render)(this._vdom, this._root);\n    }\n\n    disconnectedCallback () {\n      this._vdom = null;\n      render(null, this._root);\n    }\n\n    attributeChangedCallback (name: string, _: any, newValue: any) {\n      this.parseAttribute(name, newValue);\n    }\n  }\n\n  // Keep Preact props and DOM props in sync\n  (options.properties ?? []).forEach(name => {\n    const isAssociatedField = name === options.formAssociated;\n    const config = options.attributes?.[name];\n    const unparser = config && (\"reflect\" in config) && config.reflect;\n    Object.defineProperty(PreactElement.prototype, name, {\n      get () {\n        return this._vdom.props[name];\n      },\n      set (v) {\n        this.updateProp(name, v);\n        if (unparser) {\n          this.setAttribute(name, unparser(v));\n        }\n        if (isAssociatedField && this._internals) {\n          this._internals.setFormValue(v);\n        }\n      },\n    });\n  });\n\n  return PreactElement;\n};\n\nexport const register = (Component: PreactComponent, tagName: string, options: Options) => {\n  const element = makeCustomElement(Component, options);\n  return customElements.define(tagName, element);\n};\n"],"names":["toCamelCase","str","_","c","Slot","props","h","makeCustomElement","Component","options","PreactElement","__publicField","name","value","cloneElement","render","rawValue","prepend","_a","_b","config","parser","attributes","childNodes","i","hydrate","newValue","isAssociatedField","unparser","v","register","tagName","element"],"mappings":"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"}